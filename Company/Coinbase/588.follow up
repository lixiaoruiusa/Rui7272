588:
scalability和reliability
写完问了系统设计，怎么scale。
以及怎么搜索给定folder path下的所有文件。
他问了有哪些api，
schema，
db怎么存，
整个workflow是怎么样的，
怎么sharding.

4. system design部分是针对这个file system扩展问的
     1. 如何防止一个这个host 出问题 --》 replica for backup
     2. 如何保证strong consistency
     3. 考虑scalability的话如何设计
     4. 考虑大的read tps的话如何支持
System design的话，基本上就是用replica防止single point failure，但由此产生consistency的问题。有两种方法实现，优缺点是什么。
所以之后问我strong consistency怎么保证我就说之前提到的方法一就可以。
scalability就是如何shard/partition不同directory到不同的file system server上。LoadBalancer，hash logic，hot partition risk & mitigation
read tps就简单了，增加replica， 但由此造成write latency的问题，所以如果write很少read很多可以，不然可能要在write latency和strong consistency中间做平衡

其实前面还问了http相关的，就是进一步让你理解这个file system的管理是通过http request。就相当于一个service。
我是从database相关角度讲的，一般为了防止single point failure会选择再复制两份数据，例如一个master instance加两个replica instance。一种是single master来handle write request，在更新master node file system的时候也要更新两个replica，直到收到两个replica更新file system成功的消息后才返回给200给这个write request。 这种的话latency慢，reliability容易受影响但是所有instance上的数据理论上都是统一的。因为你的replica也要serve read requests。第二种就是不等replica更新完就返回200，这样子write latency低很多， replica那边的更新是会有一定延时算是eventual consistency。 相对single master，multiple master with load balancer就是第三问scalability的回答。


之前刷面经以为妥妥的是 in memory file system
结果出了 买卖书籍的题
有点像股市的order book, 首先有一些 buy order， 再有一些 sell order
这些order 不会匹配
自己写个method去买/卖书，在提供一个你期望的价格
我写的大概就是tradeBook(isBuy, price) 这样的一个method
如果能匹配就提供order book里面最好的价格（buy就是最低的，sell就是最高的），不match 就加到order book里面
我用的min max heap分别写了buyOrderbook 和 sellOrderBook

Follow up 1：我这个method地方有什么不OK的地方
一开始想了半天也没想出来..觉得bug free
后来我发现没有handle order book空了的情况，但面试官显然找的不是这个
后来又谈到price上的问题，我才反应过来 price不能为负值。
Follow up 2: 这些offer 会expire
我就自己建了一个custom class 里面有一个expireDate
在call我的method的时候，遇见expire的就poll掉，直到找到不expire的match..
面试官也同意了，其实没完全写完就叫停了‍‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‍‌‌‍。紧接着问了问time complexity啥的


请问楼主关于 buy and sell textbooks 那道题 的input和output到底是什么啊？
我的理解是这个market place 只有两个api ---> sell 和 buy
大概就是这样一个object
class BookMarket(object):
    def __init__(self) -> None:
        self.buys = PriorityQueue()
        self.sells = PriorityQueue()
    def buy(self, price):
        pass
    def sell(self, price):
        pass
然后人们只能interact with sell and buy function. 所以每个order是individually added.




Leetcode 28
Leetcode 241
772. Basic Calculator III

